#!/bin/bash
# Cut long audio files longer than the normal CD length and burn them on CD
#
# Requirements:
#	cdrkit/cdrtools (wodim)
#	ffmpeg
#	ffprobe
#	mktemp

# Set shell options
set -ef

# Setting:
# length of a CD (can also be done with the `-l` option)
cd_length="4740"
# length of a track (can also be done with the `-s` option)
split_length="600"
# path to disk
cd_path="/dev/sr0"
# utility to get the audio length in seconds
LEN_PROG="Ffprobe"
LEN_ARG="-show_format -v quiet"
# conversion utility
CONV_PROG="ffmpeg"
CONV_ARG="-y -loglevel error -acodec pcm_s16le -ac 2 -f wav"
CONV_START="-ss"
CONV_TIME="-t"
# burning utility
BURN_PROG="wodim"
BURN_ARG="-s -dao -swab -pad"
# flag for burning utility to only test burn
test_arg="-dummy"

# display help screen
usage() {
	echo "Usage: $0 [-h | --help] [-l TIME] [-s TIME] FILE"
	echo "  -d          Path to disk device to burn file on (default /dev/sr0)"
	echo "  -l TIME     Maximum audio length per CD. Time in seconds (default 4740)."
	echo "  -s TIME     Split podcast into multiple tracks with a length of TIME."
	echo "              TIME in seconds. If TIME equals 0, no split is made."
	echo "              (default 600)."
	echo "  -t          Make a test run before burning on a physical disk"
	echo "  -h, --help  Show this message"
}

Ffprobe() {
	args="$1"
	file="$2"

	ffprobe $args "$file" | sed -ne '/duration/s/.*=//p' | grep -Eo '^[0-9]+'
}

splits() {
	prog="$1"
	args="$2"
	file="$3"
	split="$4"

	if [ "$split" -eq "0" ]; then
		echo 1
	else
		length="$($prog "$args" "$file")"
		[ "$length" -gt "$cd_length" ] && length="$cd_length"
		splits="$(($length/$split))"
		[ "$(($length%$split))" -lt "$(($split/2))" ] && ((splits=$splits-1))
        [ "$splits" -lt "1" ] && splits=1

		echo "$splits"
	fi
}

start_time() {
	prefix="$1"
	length="$2"
	num="$3"
	start="$(($num*$length))"

	echo "$prefix" "$start"
}

convert() {
	prog="$1"
	args="$2"
	start_arg="$3"
	time="$4"
	time_arg="$5"
	splits="$6"
	split_length="$7"
	out_dir="$8"

	echo "Converting to CD audio..."

	for i in $(seq 0 "$(($splits-1))"); do
		offset="$(start_time "$start_arg" "$split_length" "$i")"

		if [ "$i" -eq "$(($splits-1))" ]; then
			split_length="$(($time-${offset##$start_arg}))"
			echo $prog $offset $args $time_arg "$split_length" "$out_dir"/"$i".wav
			$prog $offset $args $time_arg "$split_length" "$out_dir"/"$i".wav
		else
			echo $prog $offset $args $time "$out_dir"/"$i".wav
			$prog $offset $args $time_arg "$split_length" "$out_dir"/"$i".wav
		fi
	done
}

burn() {
	prog="$1"
	args="$2"
	disk="$3"
	dir="$4"

    files="$(find "$dir" -type f | sort)"

	echo "Burning on disk..."
	echo $prog $args $disk $files
	$prog $args $disk $files
}

finish() {
	echo "Removing temporary files..."
	rm -rf "$conv"
}

# initialize variables
audio_file=
splits=

# parse commandline parameters
[ "$#" -eq "0" ] && usage && exit 1
while [ "$#" -gt "0" ]; do
	case "$1" in
		-d) cd_path="$2"; shift;;
		-l) cd_length="$2"; shift;;
		-s) split_length="$2"; shift;;
		-t) test_run=1;;
		-h|--help) usage; exit 0;;
		-*) usage; exit 1;;
		*) audio_file="$1"; break;;
	esac
	shift
done

[ "$split_length" -gt "$cd_length" ] && echo "Tack split is bigger than the total CD length" && exit 1
splits="$(splits "$LEN_PROG" "$LEN_ARG" "$audio_file" "$split_length")"

# used for conversion; temporary
conv="$(mktemp -d)"
[ "$?" -ne "0" ] && echo "Cannot create temporary directory..." && exit 1
trap finish EXIT

[ -z "$test_run" ] && test_arg=""

convert "$CONV_PROG" "-i ${audio_file} ${CONV_ARG}" "$CONV_START" "$cd_length" "$CONV_TIME" "$splits" "$split_length" "$conv"
[ "$?" -ne "0" ] && echo "Error when converting audio file..." && exit 1

burn "$BURN_PROG" "${test_arg} ${BURN_ARG}" "dev=${cd_path}" "$conv"
[ "$?" -ne "0" ] && echo "Error when burning to CD..." && exit 1
